#include <iostream>
#include <filesystem>

// ---------------------------------------------------------------------------------------------------------

#define KEY "qwertyuiopasdfgh"      // 128-bit key
#define KEY_LEN 128
#define ENC_END ".enc"
#define ENC_LEN 4

// ---------------------------------------------------------------------------------------------------------


// Functions
// ---------------------------------------------------------------------------------------------------------

void path_pass       (const std::string& path, const std::string& key, const int& key_len, const char& mode);
void crypt_one_file  (const std::string& path, const std::string& key, const int& key_len);
void decrypt_one_file(const std::string& path, const std::string& key, const int& key_len);
void func_xor        (const void* data, const int& data_len, const void* key, const int& key_len);       // Xor data with key

// ---------------------------------------------------------------------------------------------------------



int main() 
{
    std::string path = "./test";
    char mode = '\0';

    std::cout << "Please, enter path for crypt/decrypt:\n";
    std::cin >> path;
    while (mode != 'e' && mode != 'd')
    {
        std::cout << "Choose mode (e/d): ";
        std::cin >> mode;

        if (mode != 'e' && mode != 'd')
        {
            std::cout << "Please enter only 'e' or 'd'!!!\n";
        }

        else
        {
            path_pass(path, KEY, KEY_LEN, mode);
        }
    }
}



// ---------------------------------------------------------------------------------------------------------
// Function's implementations
// ---------------------------------------------------------------------------------------------------------


void path_pass(const std::string& path, const std::string& key, const int& key_len, const char& mode) 
{
    std::filesystem::directory_iterator main_iter;      // Current iterator
    std::filesystem::directory_iterator end_iter;       // End of folder

    try
    {
        main_iter = std::filesystem::directory_iterator(path);
    }

    catch(const std::exception& e)
    {
        std::cerr << "Error in directory_iterator: ";
        std::cerr << e.what() << '\n';
    }
    
    
    if (main_iter == end_iter)      // Empty folder
    {
        return;
    }


    for (; main_iter != end_iter; main_iter++)
    {
        // If path is a directory
        if (std::filesystem::is_directory(main_iter->path().string()))
        {
            path_pass(main_iter->path().string(), key, key_len, mode);
        }

        else
        {
            if      (mode == 'e')
                crypt_one_file(main_iter->path().string(), key, key_len);

            else if (mode == 'd')
                decrypt_one_file(main_iter->path().string(), key, key_len);
        }
    }
}



void crypt_one_file(const std::string& path, const std::string& key, const int& key_len) 
{
    // Check the file, to not be encrypted adain
    if (path.substr(path.length() - ENC_LEN, ENC_LEN) == ENC_END)
    {
        std::cout << "File " << path << ", already encrypted" << std::endl;
        return;
    }
    

    // Open file
    FILE* fd = fopen(path.c_str(), "r+");
    if (!fd)
    {
        std::cout << "File " << path << "does not exists!" << std::endl;
        return;
    }


    // Read file data
    int buffer_size = 1024000;      // 1 MB
    std::shared_ptr<char> buffer(new char[buffer_size]);
    int readed = 0;


    while ((readed = fread((void*) buffer.get(), sizeof(char), buffer_size, fd)) > 0)
    {
        // Crypt data
        func_xor((void*) buffer.get(), readed, (void*) key.data(), key_len);

        fseek(fd, -readed, SEEK_CUR);
        fwrite((void*) buffer.get(), sizeof(char), readed, fd);
    }

    // Close and rename file
    fclose(fd);

    std::cout << "Crypted " << path << std::endl;

    std::rename(path.c_str(), (path + ENC_END).c_str());
}



void decrypt_one_file(const std::string& path, const std::string& key, const int& key_len)
{
    // Check to decrypt only crypted files
    if (path.substr(path.length() - ENC_LEN, ENC_LEN) != ENC_END)
    {
        std::cout << "File " << path << ", was not encrypted" << std::endl;
        return;
    }
    

    // Open file
    FILE* fd = fopen(path.c_str(), "r+");
    if (!fd)
    {
        std::cout << "File " << path << "does not exists!" << std::endl;
        return;
    }


    // Read file data
    int buffer_size = 1024000;      // 1 MB
    std::shared_ptr<char> buffer(new char[buffer_size]);
    int readed = 0;


    while ((readed = fread((void*) buffer.get(), sizeof(char), buffer_size, fd)) > 0)
    {
        // Decrypt data
        func_xor((void*) buffer.get(), readed, (void*) key.data(), key_len);

        fseek(fd, -readed, SEEK_CUR);
        fwrite((void*) buffer.get(), sizeof(char), readed, fd);
    }


    // Close and rename file
    fclose(fd);
    std::cout << "Decrypted " << path << std::endl;
    std::rename(path.c_str(), (path.substr(0, path.length() - ENC_LEN)).c_str());
}



void func_xor(const void* data, const int& data_len, const void* key, const int& key_len)
{
    for (int i = 0; i < data_len; i++)       // It is not the bes realisation, but for now it's ok
    {
        ((char*) data)[i] ^= ((char*)key)[i % key_len];
    }
}
